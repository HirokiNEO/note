この記事ではマネージヒープのオブジェクトの生存期間とガベージコレクタの動作についての説明を行う  
  
パワーポイント等については下記からダウンロードできる。  
http://needtec.sakura.ne.jp/doc/managedheap.pdf  
  
  
# マネージヒープにオブジェクトを割り当てる  
オブジェクトをマネージヒープに格納する場合、下記の情報が格納されるようにする。  
  
 __オーバヘッドフィールド__ (32bitプロセス:8byte, 64bitプロセス:16Byte)  
　・型オブジェクトポインター  
　　...オブジェクトの実際の型を現す型構造体へのポインタ  
　・同期ブロックインデックス  
　　...ロックとかCOMで利用する  
 __型のフィールド__   
  
次の例ではマネージヒープにオブジェクトを追加していく例を図で表したものである。  
  
https://qiita-image-store.s3.amazonaws.com/0/47856/d2bd9433-62cc-d114-dd3b-ae2636c9760e.png  
  
この状態でオブジェクトAを割り当てようとする。  
この際、オーバヘッドフィールドとフィールドが入るようにNextObjPtrは加算される。  
  
https://qiita-image-store.s3.amazonaws.com/0/47856/5a7ef010-5621-0544-fd34-6f08ef67f342.png  
  
オブジェクトBを割り当てる場合も同様に、NextObjPtrの直後からオブジェクトBが割り当てられる。  
https://qiita-image-store.s3.amazonaws.com/0/47856/f40ad465-24d8-a756-9d68-082ec8ca5ad1.png  
  
このようにオブジェクトの割り当ては単なるポインタの加算なので非常に速い。  
  
しかし、オブジェクトを割り当て続けると以下のようにマネージヒープに格納できない状況に陥る。  
https://qiita-image-store.s3.amazonaws.com/0/47856/0f6e4da1-3f93-c708-1d1c-e0db11abf298.png  
  
このとき、アプリケーションがアクセスしなくなったヒープ内のオブジェクトを削除するためにガベージコレクションを行う。  
  
# ガベージコレクション  
## ガベージコレクションの手順  
ガベージコレクションの手順は以下の通りである。  
  
１．全てのスレッドを一時停止  
　　ガベージコレクション終わるまですべてのスレッドがオブジェクトにアクセスできない  
２．マーキングフェイズ  
　　使ってないオブジェクトを探す  
３．コンパクションフェイズ  
　　不要なオブジェクトを削除して圧縮する  
  
## マーキングフェイズ  
使ってないオブジェクトを探し、同期ブロックインデックスフィールドに含まれているビットにマークを付与していく作業をマーキングフェイズという。  
  
以下にその例を図で表す。  
  
https://qiita-image-store.s3.amazonaws.com/0/47856/3f20c6cb-9f1e-e4b6-5011-2ff5ee37699f.png  
  
クラスの静的またはインスタンスフィールド、 メソッドの実引数、ローカル変数などで 参照型の変数を総称してルートと呼ぶ。  
  
この例だと以下のオブジェクトがルートから参照されている  
A,C,D,F  
  
そして、オブジェクトDからオブジェクトGを参照されている。  
  
まず、全オブジェクトの同期ブロックインデックスフィールドに含まれているビットに０を指定する。これはすべてのオブジェクトを削除するという意味である。  
  
https://qiita-image-store.s3.amazonaws.com/0/47856/ea676485-0216-decc-de77-36564e4b3973.png  
  
ルートから直接参照されているオブジェクトをマークする。  
https://qiita-image-store.s3.amazonaws.com/0/47856/596855cf-d57d-85bc-17c3-48f62e43cd4b.png  
  
マークをする際に、もし他のオブジェクトを 参照している場合は、そのオブジェクト もマークする。  
https://qiita-image-store.s3.amazonaws.com/0/47856/a83f951b-9a36-7b6e-7444-8ffae206aae5.png  
  
この例だとオブジェクトDが参照しているオブジェクトGをマークする。  
  
すべてのオブジェクトにマークをつけたらマーキングフェイズは終了である。マークされたオブジェクトは到達可能 といい。マークされていないのは到達不能という。  
  
## コンパクションフェイズ  
マークされているオブジェクトを移動させて メモリ上に連続するようする。  
  
https://qiita-image-store.s3.amazonaws.com/0/47856/a519decc-b49c-3b19-6a8c-6b38af7df08a.png  
  
オブジェクトを移動させる際に、 オブジェクトを参照しているルートなどは移動した分のバイト数を引く必要がある。  
  
マークされているすべてのオブジェクトに対して、同様の処理を行う。  
https://qiita-image-store.s3.amazonaws.com/0/47856/9eaf9e29-099f-4fbc-a552-9ef4f998b80c.png  
  
これにより、メモリの空容量を連続的にし、マネージヒープ上でメモリの断片化がなくなる。  
  
## ガベージコレクションを行ってもメモリが足りない場合  
ガベージコレクションを行ってもメモリが足りない場合はOutOfMemoryExceptionの例外が発生する。 アプリケーションはその例外をキャッチして回復を試みることができるが、ほとんどのアプリケーションは、その例外をハンドリングしていないのでプロセスが終了して、OSがプロセスが使用していたメモリを解放する。  
  
# メソッド内のオブジェクトの生存期間について  
メソッド内のオブジェクトの生存期間は最後に参照したところまでである。  
 __メソッドの終了時までではない。__   
  
https://qiita-image-store.s3.amazonaws.com/0/47856/99db5af4-d73b-c180-4e6d-15465dd505ea.png  
  
なおDebugでビルドした場合、JITコンパイラが生存期間を恣意的にメソッドの最後まで伸ばしている。  
このことは、ReleaseビルドとDebugビルドで動作が異なることを意味する。  
  
# 世代別ガベージコレクタ  
CLRのGCは世代別ガレージコレクタを採用している。  
世代別ガベージコレクタには以下の前提がある。  
  
・オブジェクトが新しいほど、その生存期間は短い  
・オブジェクトが古いほど、その生存期間は長い  
・ヒープの一部分の回収はヒープ全体の回収より高速である  
  
以下にその例を図であらわす。  
まず、新しく追加されるオブジェクトは常に 世代０に追加される。  
https://qiita-image-store.s3.amazonaws.com/0/47856/00427b76-335b-3ce2-67d1-5a602e19d5f3.png  
  
オブジェクトCとEが到達不能となり、その後、ガベージコレクションが発生したとする。  
https://qiita-image-store.s3.amazonaws.com/0/47856/8a6fdfe6-0b3f-f967-37fa-b77565f6962f.png  
  
ガベージコレクションの後に世代０で生き残ったオブジェクトが世代１に移動して世代０は空になる。  
https://qiita-image-store.s3.amazonaws.com/0/47856/f44f5570-c85d-e0fd-9078-29f05d1d9212.png  
  
  
新しいオブジェクトは世代０に割り当てられていく。  
世代０の予約サイズを超えた場合に ガベージコレクションが実行される。  
https://qiita-image-store.s3.amazonaws.com/0/47856/f5466b37-7298-f9cb-4bf7-b8b7992eb833.png  
  
  
世代０のオブジェクトのみが検査され、生き残ったオブジェクトは世代１に移動する。 世代１は検査していないので、オブジェクトBは 生き残る  
https://qiita-image-store.s3.amazonaws.com/0/47856/19ef2c90-cc99-fb01-5d64-4c4b7f2c474c.png  
  
  
ガベージコレクションを実行していくとこのように世代１が徐々に増加していく。  
https://qiita-image-store.s3.amazonaws.com/0/47856/cab6282e-1e5c-bf09-1ab0-7587c0993e47.png  
  
  
世代１のサイズが上限を超えた時にガベージコレクションが発生したとする。  
https://qiita-image-store.s3.amazonaws.com/0/47856/f600367d-9ddf-98ef-2c03-63d97e4c3d9c.png  
  
この時は、世代１～世代０のオブジェクトを検査する。  
結果以下のようになる。  
・世代１の到達可能オブジェクトは世代２となる。  
・世代０の到達可能オブジェクトは世代１となる  
  
https://qiita-image-store.s3.amazonaws.com/0/47856/1627f6e0-700a-267c-1821-11d8c2eb03e6.png  
  
このように、世代別ガベージコレクタでは、すべてのオブジェクトを検査せずに必要な世代のみ検査している。  
  
## GCの起動要因  
GCの起動要因は以下の通りである。  
  
・世代０の使用量が予約サイズを超えた  
　予約サイズはCLRが動的に決める  
・System.GCをコードで実行  
・Windowsが空容量低下の状況を報告  
  
# ラージオブジェクト  
CLRは個々のオブジェクトをスモールオブジェクトかラージオブジェクトのどちらかであると見なす。現在85,000バイト以上をラージオブジェクトとみなしている。（※ただし、変更される可能性ある）  
  
ラージオブジェクトはスモールオブジェクトと違うアドレス空間に割り当てられる  
•ラージオブジェクト⇒Large Object Heap（LOH)  
•スモールオブジェクト⇒Small Object Heap (SOH)  
  
GCはラージオブジェクトに対してコンパクションを行わない。  
  
ラージオブジェクトは割り当て後、すぐに世代２の一部とみなされる。  
世代２でGCが実行される時じゃないとラージオブジェクトに対してGCは行われない。  
  
ラージオブジェクトにコンパクションを行わないということはメモリの断片化（フラグメンテーション）が発生することを意味する。  
  
これらの動きを次に図で表す。  
https://qiita-image-store.s3.amazonaws.com/0/47856/06be4e26-12b1-c226-2e00-00f46e504451.png  
  
オブジェクトB,Cが到達不能になったとする。  
https://qiita-image-store.s3.amazonaws.com/0/47856/d03d8bed-09e0-20e9-60b7-80a5faeb1656.png  
  
ガベージコレクション発生後、到達不能の オブジェクトは解放され、１つの空き容量を作成する。この際、コンパクションは行わない。  
https://qiita-image-store.s3.amazonaws.com/0/47856/7583337e-cd2e-571e-332c-60a6c2a317da.png  
  
オブジェクトEの割り当て要求に対応するために 作成した空き容量が使用できる。  
https://qiita-image-store.s3.amazonaws.com/0/47856/8906c0d2-d06b-b753-216e-e85d68cffc65.png  
  
このようにコンパクションしないで使い続けると次のように、メモリが断片化する。  
https://qiita-image-store.s3.amazonaws.com/0/47856/04daa6dd-fa3c-8721-cf29-2398e2ce0d05.png  
  
メモリが断片化すると、トータルの空き容量としては十分に足りていても、メモリが割り当てられずOutOfMemoryExceptionがスルーされる可能性がある。  
  
## .NETFramework別のLOHの断片化  
Andrew Hunterは、メモリの断片化に関しての最悪の場合の事例を再現したテストプログラムを公開している。  
  
 __The Dangers of the Large Object Heap__   
https://www.simple-talk.com/dotnet/.net-framework/the-dangers-of-the-large-object-heap/  
  
  
実験コード：The Dangers of the Large Object Heap　より  
  
```csharp
using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime;

 
namespace TestLOH
{
    class Program
    {
        /// https://www.simple-talk.com/dotnet/.net-framework/the-dangers-of-the-large-object-heap/
        /// Static variable used to store our 'big' block. This ensures that the block is always up for garbage collection.
        /// </summary>
        static byte[] bigBlock;

        /// <summary>
        /// Allocates 90,000 byte blocks, optionally intersperced with larger blocks
        /// </summary>
        static void Fill(bool allocateBigBlocks, bool grow, bool alwaysGC)
        {
            // Number of bytes in a small block
            // 90000 bytes, just above the limit for the LOH
            const int blockSize = 90000;

            // Number of bytes in a larger block: 16Mb initially
            int largeBlockSize = 1 << 24;

            // Number of small blocks allocated
            int count = 0;

            try
            {
                // We keep the 'small' blocks around
                // (imagine an algorithm that allocates memory in chunks)
                List<byte[]> smallBlocks = new List<byte[]>();
                for (; ;)
                {
                    // Write out some status information
                    if ((count % 1000) == 0)
                    {
                        Console.CursorLeft = 0;
                        Console.Write(new string(' ', 20));
                        Console.CursorLeft = 0;
                        Console.Write("{0}", count);
                        Console.CursorLeft = 0;
                    }

                    // Force a GC if necessaryry
                    if (alwaysGC)
                    {
                        GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;
                        GC.Collect();
                    }
 
                    // Allocate a larger block if we're set up to do soso
                    if (allocateBigBlocks)
                    {
                        bigBlock = new byte[largeBlockSize];
                    }
 

                    // The next 'large' block will be just slightly largerer
                    if (grow) largeBlockSize++;
 
                    // Allocate a new block
                    smallBlocks.Add(new byte[blockSize]);

                    count++;
                }
            }
            catch (OutOfMemoryException)
            {
                // Force a GC, which should empty the LOH again
                bigBlock = null;

                GC.Collect();
                // Display the results for the amount of memory we managed to allocate
                Console.WriteLine("{0}: {1}Mb allocated"
                                  , (allocateBigBlocks ? "With large blocks" : "Only small blocks")
                                  + (alwaysGC?", frequent garbage collections":"")
                                  + (grow?"":", large blocks not growing")
                                  , (count * blockSize) / (1024 * 1024));

            }
        }
 
        static void Main(string[] args)
        {

            // Display results for cases both with and without the larger blocks
            Fill(true, true, false);
            Fill(true, true, true);
            Fill(false, true, false);
            Fill(true, false, false);
        
            Console.ReadLine();
        }
    }
}

```  
  
テスト環境：  
VisualStudio2013 Expressでx86のアプリケーションを作成  
Windows7 SP1 64bit  
メモリ 4.00GB  
  
結果：  
  
|Console|2.0|3.0|3.5|4.0|4.5|  
|:------|:--|:--|:--|:--|:--|  
|With large blocks|19Mb|19Mb|20Mb|1546Mb|1546Mb|  
|With large blocks, frequent garbage collection|23Mb|23Mb|23Mb|1570Mb|1570Mb|  
|Only small blocks|1572Mb|1620Mb|1588Mb|1643Mb|1643Mb|  
|With large blocks, large blocks not growing|1375Mb|1596Mb|1419Mb|1636Mb|1620Mb|  
  
  
この結果より、.NET4.0より前ではLOHの断片化の状況によっては数十MB程度しか確保できなくなる場合があることが確認できる。  
  
このことは、LOHを扱うアプリケーションを作成する場合は、.NET4.0以降を選択した方がのぞましいことを意味している。  
  
なお、.NET4.5.1ではLOH領域に対してコンパクションを行う命令が追加されている。  
  
```csharp
Using System;
Using System.Runtime;

// LOHに対するコンパクションを要求
GCSettings.LOHCompactionMode =
GCLargeObjectHeapCompactionMode.CompactOnce;

// GCが発生してLOHがコンパクションされる
GC.Collect():
```  
  
# Finalization  
オブジェクトがGCにより回収対象になった後で、オブジェクトのメモリが解放される前に何らかのコードを実行できる。  
  
Finalizeメソッドの例：  
  
```csharp
class Hoge{
  // Finalizeメソッド
  ~Hode() {
  // }
}
```  
  
C++のデストラクタと似ていますが、動作は異なる。   
C++ではスコープを外れた時に、確実に呼ばれる。   
C#ではFinalizeメソッドが実行されるタイミングは全く制御できない。  
  
Finalizationの動作について以下に図であらわす。  
https://qiita-image-store.s3.amazonaws.com/0/47856/7321f8be-be21-f042-f33f-d9c4ecdf63d0.png  
  
Finalizeメソッドが定義してあるオブジェクトを 割り当てる際、型インスタンスコンストラクターが呼ばれる前にファイナライゼーションリストにオブジェクトのポインタが配置される。  
  
オブジェクトC、D、Fが参照されなくなったとする。  
https://qiita-image-store.s3.amazonaws.com/0/47856/5431ab76-cf0b-1bb9-a62f-a333e7db4950.png  
  
  
その後、ガベージコレクションを実行すると次のようになる。  
https://qiita-image-store.s3.amazonaws.com/0/47856/af9c74e0-858b-a364-6252-955752a81c3d.png  
  
FinalizeメソッドのないオブジェクトDは削除され、 Finalizeメソッドのあるオブジェクト、C、FはFリーチャブルキューへ参照が移動する。  
  
Fリーチャブルキューにデータが入ると、 Finalize用のスレッドが動作してキューからデータを 取り出して、Finalizeメソッドを実行する。  
この結果、Fリーチャブルキューから参照が消えて、C,Fオブジェクトは到達不能となる  
  
https://qiita-image-store.s3.amazonaws.com/0/47856/f4ff7784-c6d2-c46e-5e74-bce9cc06ce87.png  
  
その後、ガベージコレクションを実行した後で オブジェクトは削除される  
https://qiita-image-store.s3.amazonaws.com/0/47856/bd9f669a-5766-d271-656c-39a06c8018fa.png  
  
つまり、Finalizeを使うオブジェクトは削除されるまでに、最低２回のガベージコレクションが必要になる。  
  
# 参考  
 __プログラミング .NET Framework 第4版__   
http://www.amazon.co.jp/dp/4822294951  
  
 __CLR オブジェクトヘッダーの構造__   
http://shoutakenaka.blogspot.jp/2009/09/clr.html  
  
 __The Dangers of the Large Object Heap__   
https://www.simple-talk.com/dotnet/.net-framework/the-dangers-of-the-large-object-heap/  
